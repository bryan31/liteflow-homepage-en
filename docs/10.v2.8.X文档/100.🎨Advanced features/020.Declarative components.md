---
title: üçáDeclarative components
date: 2022-07-02 22:02:46
permalink: /pages/f33919/
---

What is a declarative component?

The common components and conditional components introduced in the previous chapters require you to define a class to inherit `NodeComponent` or `NodeSwitchComponent`. This causes coupling. Since Java is a single inheritance system, users can no longer inherit their own classes, which reduces a lot of freedom.

This feature of declarative components allows your custom components to not inherit any classes and implement any interfaces. Ordinary classes can also use annotations to define components.



## Declaration of common components

You can declare a common component as follows:

```java
@LiteflowComponent("a")
@LiteflowCmpDefine
public class ACmp{
  
	@LiteflowMethod(LiteFlowMethodEnum.PROCESS)
	public void processAcmp(NodeComponent bindCmp) {
		System.out.println("ACmp executed!");
	}

	@LiteflowMethod(LiteFlowMethodEnum.IS_ACCESS)
	public boolean isAcmpAccess(NodeComponent bindCmp){
		return true;
	}

	@LiteflowMethod(LiteFlowMethodEnum.BEFORE_PROCESS)
	public void beforeAcmp(String nodeId, Slot<DefaultContext> slot){
		System.out.println("before A");
	}

	@LiteflowMethod(LiteFlowMethodEnum.AFTER_PROCESS)
	public void afterAcmp(String nodeId, Slot<DefaultContext> slot){
		System.out.println("after A");
	}

	@LiteflowMethod(LiteFlowMethodEnum.ON_SUCCESS)
	public void onAcmpSuccess(NodeComponent bindCmp){
		System.out.println("Acmp success");
	}

	@LiteflowMethod(LiteFlowMethodEnum.ON_ERROR)
	public void onAcmpError(NodeComponent bindCmp){
		System.out.println("Acmp error");
	}
	
	@LiteflowMethod(LiteFlowMethodEnum.IS_END)
	public boolean isAcmpEnd(NodeComponent bindCmp) {
		return false;
	}
}
```



Users do not need to inherit `NodeComponent` on the class you define, as long as the class is annotated with `LiteflowCmpDefine` and the corresponding method is annotated with `LiteflowMethod`, a component can be defined.

The role of `LiteFlowMethod` is to map your own defined methods to component methods.



::: tip tip

It should be noted here that the parameters of most methods must be passed in the parameter `NodeComponent bindCmp`, and there must be only one parameter, otherwise an error will be reported, and `beforeProcess` and `afterProcess` are still defined according to the previous parameters. Note this, see the example above.

In the past, the `this` keyword was used to get the context bean, but now you only need to get it from bindCmp.

The name of the method can be defined any way you want. There is no limit to this.

:::

## Declaration of switch components

Declaring a switch component is similar to a common component, as follows:

```java
@Component("e")
@LiteflowSwitchCmpDefine
public class ECmp{

    @LiteflowMethod(LiteFlowMethodEnum.PROCESS_SWITCH)
    public String processSwitch(NodeComponent bindCmp) throws Exception {
        System.out.println("Ecomp executed!");
        return "g";
    }
}
```



## About implementation

Declarative components are implemented by dynamic proxy, and the underlying dynamic proxy framework is ByteBuddy.

All dynamic proxy classes have their class names processed during registration, so you will see the following log prints:

```
2022-05-16 13:05:56.492  INFO 73054 --- [           main] c.y.l.test.base.cmp.ByteBuddy$a$JLWBAK   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$a$JLWBAK] execution
2022-05-16 13:05:56.496  INFO 73054 --- [           main] c.y.l.test.base.cmp.ByteBuddy$b$JZXUWG   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$b$JZXUWG] execution
2022-05-16 13:05:56.505  INFO 73054 --- [lf-when-thead-0] c.y.l.test.base.cmp.ByteBuddy$c$RWWUCJ   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$c$RWWUCJ] execution
2022-05-16 13:05:56.506  INFO 73054 --- [lf-when-thead-1] c.y.l.test.base.cmp.ByteBuddy$d$RECNPY   : [51fbe478db8c4b2cb7ad7519aee0b92d]:[O]start component[ByteBuddy$d$RECNPY] execution
```



If you look carefully, you will find that the format of all dynamic proxy class names is: **ByteBuddy$your component name$random 6-digit string**.

If you use declarative components, you only need to look at the middle of the two $s, which is your component ID. Some people may have doubts about this point, so I will explain it here.